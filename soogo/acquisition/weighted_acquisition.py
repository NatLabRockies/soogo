"""Weighted acquisition function for surrogate-based optimization."""

# Copyright (c) 2025 Alliance for Energy Innovation, LLC

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

__authors__ = ["Weslley S. Pereira"]

import numpy as np
from scipy.spatial.distance import cdist
from typing import Optional

from .base import Acquisition
from .utils import select_weighted_candidates
from ..model import Surrogate
from ..sampling import random_sample


class WeightedAcquisition(Acquisition):
    """Select candidates by minimizing a weighted score that balances
    surrogate value and distance to existing samples.

    The weighted score is :math:`w f_s(x) + (1-w)(-d_s(x))`, where
    :math:`f_s(x)` is the surrogate-predicted value at :math:`x` and
    :math:`d_s(x)` is the distance from :math:`x` to its closest neighbor in
    the current sample. Both components are scaled to [0, 1] over the candidate
    pool. Candidates are generated by a space-filling sampler and the best
    points under the weighted score are selected. See [#]_.

    This acquisition also supports multi-objective surrogates by scoring with
    the average predicted target value across objectives. See [#]_.

    :param int pool_size: Number of candidates generated per call.
    :param float|sequence weightpattern: Weight(s) :math:`w` used in the score.
        The list is rotated after each call so subsequent selections consider
        different trade-offs. Defaults to ``[0.2, 0.4, 0.6, 0.9, 0.95, 1]``.
    :param seed: Seed or random number generator.

    .. attribute:: rng

        Random number generator.

    .. attribute:: weightpattern

        Circular list of weights used in the score; rotated after selections.

    .. attribute:: pool_size

        Number of candidates generated per :meth:`optimize()` call.

    References
    ----------
    .. [#] Regis, R. G., & Shoemaker, C. A. (2012). Combining radial basis
        function surrogates and dynamic coordinate search in
        high-dimensional expensive black-box optimization.
        Engineering Optimization, 45(5), 529â€“555.
        https://doi.org/10.1080/0305215X.2012.687731
    .. [#] Juliane Mueller. SOCEMO: Surrogate Optimization of Computationally
        Expensive Multiobjective Problems.
        INFORMS Journal on Computing, 29(4):581-783, 2017.
        https://doi.org/10.1287/ijoc.2017.0749
    """

    def __init__(
        self,
        pool_size: int = Acquisition.DEFAULT_N_MAX_EVALS_OPTIMIZER,
        weightpattern=None,
        seed=None,
        **kwargs,
    ) -> None:
        super().__init__(**kwargs)
        self.rng = np.random.default_rng(seed)
        self.pool_size = pool_size
        if weightpattern is None:
            self.weightpattern = [0.2, 0.4, 0.6, 0.9, 0.95, 1]
        elif hasattr(weightpattern, "__len__"):
            self.weightpattern = list(weightpattern)
        else:
            self.weightpattern = [weightpattern]

    def choose_candidates(
        self,
        surrogateModel: Surrogate,
        bounds,
        x: np.ndarray,
        n: int = 1,
        constr=None,
        exclusion_set: Optional[np.ndarray] = None,
    ) -> np.ndarray:
        """Select up to n candidates from x by minimizing the weighted score.

        :param surrogateModel: Surrogate model.
        :param sequence bounds: List with the limits [x_min,x_max] of each
            direction x in the space.
        :param x: Candidate points to choose from.
        :param n: Number of points to be acquired.
        :param constr: Optional constraint function. Must return a vector
            (or 2D array) with non-positive values for feasible candidates.
        :param exclusion_set: Known points, if any, in addition to the ones
            used to train the surrogate.
        :return: m-by-dim matrix with the selected points, where m <= n.
        """
        dim = len(bounds)  # Dimension of the problem

        if constr is not None:
            # Filter out candidates that do not satisfy the constraints
            constr_values = constr(x)
            if constr_values.ndim == 1:
                feasible_idx = constr_values <= 0
            else:
                feasible_idx = np.all(constr_values <= 0, axis=1)
            x = x[feasible_idx]
            if x.shape[0] == 0:
                return np.empty((0, dim))

        # Evaluate candidates
        fx = surrogateModel(x)

        if exclusion_set is None:
            exclusion_set = surrogateModel.X
        else:
            exclusion_set = np.vstack((surrogateModel.X, exclusion_set))

        # Select best candidates
        atol = self.tol(bounds)
        xselected, _ = select_weighted_candidates(
            x, cdist(x, exclusion_set), fx, n, atol, self.weightpattern
        )
        n = xselected.shape[0]

        # Rotate weight pattern
        self.weightpattern[:] = (
            self.weightpattern[n % len(self.weightpattern) :]
            + self.weightpattern[: n % len(self.weightpattern)]
        )

        return xselected

    def optimize(
        self,
        surrogateModel: Surrogate,
        bounds,
        n: int = 1,
        constr=None,
        exclusion_set: Optional[np.ndarray] = None,
        **kwargs,
    ) -> np.ndarray:
        """Generate a number of candidates using the :attr:`sampler`. Then,
        select up to n points that maximize the score.

        :param surrogateModel: Surrogate model.
        :param sequence bounds: List with the limits [x_min,x_max] of each
            direction x in the space.
        :param n: Number of points requested.
        :param constr: Optional constraint function. Must return a vector
            (or 2D array) with non-positive values for feasible candidates.
        :return: m-by-dim matrix with the selected points, where m <= n.
        """
        # Report unused kwargs
        super().report_unused_optimize_kwargs(kwargs)

        # Generate the complete pool of candidates
        x = random_sample(
            self.pool_size, bounds, surrogateModel.iindex, self.rng
        )

        return self.choose_candidates(
            surrogateModel, bounds, x, n, constr, exclusion_set
        )
